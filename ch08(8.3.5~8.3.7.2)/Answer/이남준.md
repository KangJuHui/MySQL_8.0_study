# 2024년도
## 1주차 Real MySQL 문제
#### 출제자: 이남준

### 1. 다음 중 B-Tree 인덱스에 대한 설명으로 틀린 것을 고르시오.
1. MySQL 5.7 이하 버전도 칼럼 단위로 정렬 순서를 혼합하여 인덱스를 생성할 수 있다.
2. 쿼리의 ORDER BY 처리나 MIN() 또는 MAX() 함수 등의 최적화가 필요한 경우에도 MySQL 옵티마이저는 인덱스의 읽기 반향을 전환해서 사용하도록 실행 계획을 만들어 낸다.
3. MySQL은 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조이다.
4. 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목 현상을 완화하는 데에 도움을 줄 수 있다.

답: 1

#### 참고 페이지 : p241-p247


### 2. 아래와 같이 인덱스가 설정되어있다고 가정하자.
`INDEX (dept_no, emp_no)`<br>
이 때, 아래와 같이 쿼리를 작성하면 인덱스를 효율적으로 사용할 수 없다.<br>
`SELECT * FROM dept_emp WHERE emp_no>=10144`
그 이유를 작성하시오.

답: 인덱스나 (dept_no, emp_no) 칼럼 순서대로 생성되어 있으므로, 선행 칼럼인 dept_no의 조건에 있어야 인덱스 페이지 범위를 줄여나가며 효율적으로 검색이 가능하다. 인덱스가 다중 컬럼으로 구성되어있으므로, dept_no 칼럼에 대해 먼저 정렬한 후, 다시 emp_no 컬럼 값으로 정렬되어 있기 때문이다. 하지만 본 쿼리에서는 dept_no에 대한 조건이 없으므로, emp_no 조건을 찾기 위해 모든 컬럼에 대해 풀 스캔이 이루어져야 한다.

#### 참고 페이지 : p249-p250